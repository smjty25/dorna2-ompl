#pragma once

#include <ompl/base/SpaceInformation.h>
#include <ompl/base/spaces/RealVectorStateSpace.h>
#include <ompl/geometric/SimpleSetup.h>

#include <ompl/base/objectives/PathLengthOptimizationObjective.h>
#include <ompl/geometric/planners/rrt/RRTConnect.h>
#include <ompl/geometric/planners/rrt/RRTstar.h>
#include <ompl/geometric/planners/prm/PRMstar.h>
#include <ompl/geometric/PathSimplifier.h>



#include "URDFFK.hpp" 

#include <fcl/fcl.h>
#include <Eigen/Dense>

#include <functional>
#include <iostream>
#include <memory>
#include <optional>
#include <vector>
#include <stdexcept>
#include <numeric>

#include <filesystem>
#include <string>
#include "config.hpp"  // generated by CMake

#include <pybind11/pybind11.h>
#include <pybind11/eigen.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>
#include <Eigen/Core>

namespace py = pybind11;


namespace ob = ompl::base;
namespace og = ompl::geometric;

constexpr float PI = 3.14159265358979323846f;

// for resources
static std::string resource_path(const std::string& rel)
{
    namespace fs = std::filesystem;

    // 1) Build-tree path (when running from build dir)
    {
        fs::path p = fs::path(OMPL_DEMO_BUILD_RESOURCE_DIR) / rel;
        if (fs::exists(p)) return p.string();
    }
    // 2) Installed path (after `cmake --install`)
    {
        fs::path p = fs::path(OMPL_DEMO_INSTALL_RESOURCE_DIR) / rel;
        if (fs::exists(p)) return p.string();
    }
    // 3) Fallback: relative to current working dir (useful if user runs from project root)
    {
        fs::path p = fs::path("resources") / rel;
        if (fs::exists(p)) return p.string();
    }
    throw std::runtime_error("Resource not found: " + rel);
}

// ---------------------- Basic geometry types ----------------------
enum class ShapeType { BOX , SPHERE, CYLINDER ,MESH };

struct BoxShape {
    // Full side lengths
    double x, y, z;
};

struct Shape {
    ShapeType type{ShapeType::BOX};
    BoxShape box{};
};

static Eigen::Isometry3d poseToIso(const urdf::Pose& o) {
    Eigen::Isometry3d T = Eigen::Isometry3d::Identity();
    T.translation() = Eigen::Vector3d(o.position.x, o.position.y, o.position.z);
    Eigen::Quaterniond q(o.rotation.w, o.rotation.x, o.rotation.y, o.rotation.z);
    T.linear() = q.toRotationMatrix();
    return T;
}


struct PoseAA {
    // Position + rotation vector (axis-angle as Rodrigues rotation vector):
    // r = axis * angle_deg (so angle = |r|, axis = r / |r|)
    Eigen::Vector3d t{0,0,0};
    Eigen::Vector3d rvec{0,0,0};

    void set(Eigen::Matrix<double,6,1> in){
        t    << in(0), in(1), in(2);
        rvec << in(3), in(4), in(5);
    }

    Eigen::Isometry3d toIsometry() const {
        Eigen::Isometry3d T = Eigen::Isometry3d::Identity();
        T.translation() = t;
        double angle = rvec.norm() * PI / 180.0;
        if (angle > 1e-12) {
            Eigen::Vector3d axis = rvec / angle;
            T.linear() = Eigen::AngleAxisd(angle, axis).toRotationMatrix();
        } else {
            T.linear().setIdentity();
        }
        return T;
    }
    
};

struct ObjectInstance {
    Shape shape;
    PoseAA pose; // world pose for scene; local pose (relative to last link) for load
};

// Each robot link's collision geometry (relative to the link frame)
struct LinkCollision {
    Shape shape;
    Eigen::Isometry3d localTF = Eigen::Isometry3d::Identity(); // from link frame to shape
};
using LinkCollisions = std::vector<LinkCollision>; 
// FK callback: given q (size=DOF), return world poses for each link (size = nLinks)

using FKCallback = std::function<void(const Eigen::VectorXd& q, std::vector<Eigen::Isometry3d>& linkWorld)>;
FKCallback fk_cb;

// ---------------------- FCL helpers ----------------------
static std::shared_ptr<fcl::CollisionGeometryd> makeFclGeometry(const Shape& s) {
    switch (s.type) {
        case ShapeType::BOX:      return std::make_shared<fcl::Boxd>(s.box.x, s.box.y, s.box.z);
        default: throw std::runtime_error("Unsupported shape type");
    }
}

static bool collide(const fcl::CollisionObjectd& a, const fcl::CollisionObjectd& b) {
    fcl::CollisionRequestd req;
    fcl::CollisionResultd  res;
    fcl::collide(&a, &b, req, res);
    return res.isCollision();
}


enum class PlannerKind { RRTConnect, RRTstar, PRMstar };

struct PlannerConfig {
    PlannerKind kind = PlannerKind::RRTConnect;
    double range     = 0.10;  // step size for RRT*/RRTConnect
    double goalBias  = 0.05;  // goal sampling bias (0..1) for RRT*/RRTConnect
    // you can add PRM* options later (e.g., set max milestones, roadmap reuse, etc.)
};


inline Eigen::VectorXd stateToQ(const ompl::base::State* s, std::size_t dof) {
    using StateType = ompl::base::RealVectorStateSpace::StateType;
    const auto* rv = s->as<StateType>();
    Eigen::VectorXd q(dof);
    for (std::size_t i = 0; i < dof; ++i) q[i] = (*rv)[i];
    return q;
}

// ---------------------- Validity checker ----------------------
class RobotValidityChecker : public ob::StateValidityChecker {
public:    
    // runtime buffers
    RobotValidityChecker(const ob::SpaceInformationPtr& si,
                         size_t dof,
                         std::vector<LinkCollisions> linkGeoms,
                         FKCallback fk,
                         std::vector<ObjectInstance> scene,
                         std::vector<ObjectInstance> load,
                         Eigen::Isometry3d frame,
                         size_t lastLinkIndex)
        : ob::StateValidityChecker(si),
          dof_(dof),
          linkGeoms_(std::move(linkGeoms)),
          fk_(std::move(fk)),
          scene_(std::move(scene)),
          loadLocal_(std::move(load)),
          lastLinkIndex_(lastLinkIndex) {
        
        for (size_t i = 0; i + 1 < linkGeoms_.size(); ++i)
            adjacentPairs_.emplace_back(i, i+1);

        // Pre-build FCL geometry for environment
        envGeoms_.reserve(scene_.size());
        for (auto& obj : scene_) {
            envGeoms_.push_back(makeFclGeometry(obj.shape));
            envObjs_.emplace_back(envGeoms_.back()); // default identity, we'll set transform per check
        }
        // Pre-build FCL geometry for load
        loadGeoms_.reserve(loadLocal_.size());
        for (auto& obj : loadLocal_) {
            loadGeoms_.push_back(makeFclGeometry(obj.shape));
        }
        // Pre-build FCL geometry for robot links
        linkGeomsFcl_.clear();
        linkGeomsFcl_.reserve(
            std::accumulate(linkGeoms_.begin(), linkGeoms_.end(), size_t(0),
                            [](size_t sum, const LinkCollisions& lc) { return sum + lc.size(); })
        );

        for (const auto& link : linkGeoms_) {
            for (const auto& lc : link) {
                linkGeomsFcl_.push_back(makeFclGeometry(lc.shape));
            }
        }

        // 3) Build/update environment FCL objects
        envObjs_.clear();
        envObjs_.reserve(scene_.size());
        for (size_t i = 0; i < scene_.size(); ++i) {
            fcl::Transform3d Tf = frame * scene_[i].pose.toIsometry();
            fcl::CollisionObjectd obj(envGeoms_[i], Tf);
            obj.computeAABB();
            envObjs_.push_back(std::move(obj));
        }


    }

    bool isValid(const ob::State* s) const override {
        // 1) Extract q
        Eigen::VectorXd q(dof_);
        const auto* rv = s->as<ob::RealVectorStateSpace::StateType>();
        for (size_t i = 0; i < dof_; ++i) q[i] = (*rv)[i];

        // 2) FK: get world transform for each link
        linkWorld_.assign(linkGeoms_.size(), Eigen::Isometry3d::Identity());
        fk_(q, linkWorld_);
        if (linkWorld_.size() != linkGeoms_.size()) {
            // Defensive: FK must return same count
            return false;
        }


        // 4) Build robot link FCL objects at world pose
        linkObjs_.clear();
        linkOfObj_.clear();
        for (size_t i = 0; i < linkGeoms_.size(); ++i) {
            const Eigen::Isometry3d Tworld_link = linkWorld_[i];
            for (const auto& lc : linkGeoms_[i]) {
                auto geom = makeFclGeometry(lc.shape);
                fcl::CollisionObjectd obj(geom, Tworld_link * lc.localTF);
                obj.computeAABB();
                linkObjs_.push_back(std::move(obj));
                linkOfObj_.push_back(i);
            }
        }

        // 5) Build load objects (attached to last link)
        loadObjs_.clear();
        loadObjs_.reserve(loadLocal_.size());
        const Eigen::Isometry3d& Tlast = linkWorld_[lastLinkIndex_ ]; //flange is one after the last link
        for (size_t i = 0; i < loadLocal_.size(); ++i) {
            Eigen::Isometry3d Tworld = Tlast * loadLocal_[i].pose.toIsometry();
            fcl::CollisionObjectd obj(loadGeoms_[i], Tworld);
            obj.computeAABB();
            loadObjs_.push_back(std::move(obj));
        }

        // 6) Collision checks:
        //    - Robot links vs environment
        for (auto& linkObj : linkObjs_) {
            for (auto& envObj : envObjs_) {
                if (collide(linkObj, envObj)) return false;
            }
        }
        //    - Load vs environment
        for (auto& loadObj : loadObjs_) {
            for (auto& envObj : envObjs_) {
                if (collide(loadObj, envObj)) return false;
            }
        }
        
                // self-collision: skip same-link & adjacent links
        auto isAdjacent = [&](size_t a, size_t b) {
            if (a > b) std::swap(a,b);
            for (auto& p : adjacentPairs_) if (p.first==a && p.second==b) return true;
            return false;
        };

        for (size_t a = 0; a < linkObjs_.size(); ++a) {
            for (size_t b = a+1; b < linkObjs_.size(); ++b) {
                const size_t la = linkOfObj_[a];
                const size_t lb = linkOfObj_[b];
                if (la == lb)          continue; // shapes on same link
                if (isAdjacent(la,lb)) continue; // parent/child links
                if (collide(linkObjs_[a], linkObjs_[b])) return false;
            }
        }

        {
            //ee constrain 
            /*
            Eigen::Vector3d desired_ = Eigen::Vector3d(0.0,0.0,1.0);
            double cos_tol_ = 0.05;

            std::vector<Eigen::Isometry3d> linkWorld;
            linkWorld.reserve(6);
            fk_cb(stateToQ(s,6), linkWorld);

            Eigen::Isometry3d T_ee = linkWorld.at(6);
            Eigen::Vector3d ee = T_ee.linear().col(2); // tool X
            if (abs(ee.dot(desired_)) > cos_tol_) return false;
            */
        }

        return true; // valid
    }

private:
    size_t dof_;
    std::vector<LinkCollisions> linkGeoms_;
    FKCallback fk_;
    std::vector<ObjectInstance> scene_;
    std::vector<ObjectInstance> loadLocal_;
    size_t lastLinkIndex_;

    // prebuilt geoms
    std::vector<std::shared_ptr<fcl::CollisionGeometryd>> envGeoms_;
    std::vector<std::shared_ptr<fcl::CollisionGeometryd>> loadGeoms_;
    std::vector<std::shared_ptr<fcl::CollisionGeometryd>> linkGeomsFcl_;

    // reused buffers (mutable to allow reuse inside isValid)
    mutable std::vector<Eigen::Isometry3d> linkWorld_;
    mutable std::vector<fcl::CollisionObjectd> envObjs_;
    mutable std::vector<fcl::CollisionObjectd> linkObjs_;
    mutable std::vector<fcl::CollisionObjectd> loadObjs_;
    mutable std::vector<size_t> linkOfObj_;  // map object index -> link index
    std::vector<std::pair<size_t,size_t>> adjacentPairs_; // (i, i+1) for a chain
};

// ---------------------- Planner wrapper ----------------------
struct PlanResult {
    bool solved{false};
    std::vector<Eigen::VectorXd> path; // sequence of joint states
};

struct PlanOptions {
    double timeSeconds{1.0};
    std::optional<double> range; // step length for RRTConnect
};



class JointSpacePlanner {
public:
    JointSpacePlanner(size_t dof,
                      const std::vector<std::pair<double,double>>& jointBounds,
                      std::vector<LinkCollisions> linkGeoms,
                      size_t lastLinkIndex,
                      FKCallback fk,
                      std::vector<ObjectInstance> scene,
                      std::vector<ObjectInstance> load,
                      Eigen::Isometry3d frame,
                      PlanOptions opts = {},
                      PlannerConfig pcfg = {})
        : dof_(dof), opts_(opts), cfg_(pcfg)
    {
        // 1) Space + bounds
        auto space = std::make_shared<ob::RealVectorStateSpace>(dof_);
        ob::RealVectorBounds bnd(dof_);
        for (size_t i = 0; i < dof_; ++i) {
            bnd.setLow(i,  jointBounds[i].first);
            bnd.setHigh(i, jointBounds[i].second);
        }
        space->setBounds(bnd);

        ss_ = std::make_unique<og::SimpleSetup>(space);
        si_ = ss_->getSpaceInformation();

        // Resolution controls
        si_->setStateValidityCheckingResolution(0.01);   // ~1% of extent
        // NOTE: this is on the StateSpace, not SpaceInformation:
        ss_->getStateSpace()->setLongestValidSegmentFraction(0.01);

        // 2) Validity checker (FCL env + load)
        auto vc = std::make_shared<RobotValidityChecker>(
            si_, dof_, std::move(linkGeoms), std::move(fk),
            std::move(scene), std::move(load), frame, lastLinkIndex);
        ss_->setStateValidityChecker(vc);

        // 3) Planner
        setPlanner(cfg_);
    }

    void setPlanner(const PlannerConfig& cfg) {
        cfg_ = cfg;

        // Use path-length objective for optimizing planners
        auto obj = std::make_shared<ob::PathLengthOptimizationObjective>(si_);
        ss_->getProblemDefinition()->setOptimizationObjective(obj);

        ob::PlannerPtr pl;
        switch (cfg_.kind) {
            case PlannerKind::RRTConnect: {
                auto r = std::make_shared<og::RRTConnect>(si_);
                r->setRange(cfg_.range);
                // no setGoalBias() on RRTConnect
                pl = r;
                break;
            }
            case PlannerKind::RRTstar: {
                auto r = std::make_shared<og::RRTstar>(si_);
                r->setRange(cfg_.range);
                r->setGoalBias(cfg_.goalBias); // valid here
                pl = r;
                break;
            }
            case PlannerKind::PRMstar: {
                auto r = std::make_shared<og::PRMstar>(si_);
                pl = r;
                break;
            }
        }
        // PlanOptions.range overrides where applicable
        if (opts_.range && *opts_.range > 0.0) {
            if (auto rrts = std::dynamic_pointer_cast<og::RRTstar>(pl))    rrts->setRange(*opts_.range);
            if (auto rrtc = std::dynamic_pointer_cast<og::RRTConnect>(pl)) rrtc->setRange(*opts_.range);
        }
        ss_->setPlanner(pl);
    }

    PlanResult plan(const Eigen::VectorXd& qStart, const Eigen::VectorXd& qGoal) {
        if ((size_t)qStart.size() != dof_ || (size_t)qGoal.size() != dof_)
            throw std::runtime_error("qStart/qGoal size mismatch");

        auto space = std::static_pointer_cast<ob::RealVectorStateSpace>(ss_->getStateSpace());
        ob::ScopedState<> sStart(space), sGoal(space);

        // Fill & clamp
        for (size_t i = 0; i < dof_; ++i) {
            sStart[i] = qStart[i];
            sGoal[i]  = qGoal[i];
        }
        space->enforceBounds(sStart.get());
        space->enforceBounds(sGoal.get());

        // Small goal tolerance
        const double goalTol = 1e-3;
        ss_->setStartAndGoalStates(sStart, sGoal, goalTol);

        // Solve
        const double t = (opts_.timeSeconds > 0.0 ? opts_.timeSeconds : 1.0);
        const bool solved = ss_->solve(t);

        PlanResult out;
        out.solved = solved;
        if (!solved) return out;

        // Post-process: safe subset for older OMPLs
        og::PathSimplifier ps(si_);
        auto& pg = ss_->getSolutionPath();
        ps.reduceVertices(pg);
        ps.smoothBSpline(pg);   // if even this is unavailable in your build, fall back to simplifySolution()
        // As a fallback or extra:
        // ss_->simplifySolution(0.5); // time-limited simplification

        // Densify
        pg.interpolate();

        // Extract
        out.path.reserve(pg.getStateCount());
        for (size_t i = 0; i < pg.getStateCount(); ++i) {
            const auto* st = pg.getState(i)->as<ob::RealVectorStateSpace::StateType>();
            Eigen::VectorXd q(dof_);
            for (size_t j = 0; j < dof_; ++j) q[j] = (*st)[j];
            out.path.push_back(std::move(q));
        }
        return out;
    }

private:
    size_t dof_;
    PlanOptions opts_;
    PlannerConfig cfg_;
    ob::SpaceInformationPtr si_;
    std::unique_ptr<og::SimpleSetup> ss_;
};


//////////////////////

static std::vector<LinkCollisions>
extractLinkCollisionsFromURDF(const urdf::ModelInterfaceSharedPtr& model,
                              const std::vector<std::string>& linkNames)
{
    std::vector<LinkCollisions> out(linkNames.size());
    for (size_t i = 0; i < linkNames.size(); ++i) {
        auto link = model->getLink(linkNames[i]);
        if (!link) continue;

        std::vector<urdf::CollisionSharedPtr> cols;
        if (link->collision) cols.push_back(link->collision);
        for (auto& c : link->collision_array) cols.push_back(c);

        for (auto& c : cols) {
            if (!c || !c->geometry) continue;
            LinkCollision lc;
            lc.localTF = poseToIso(c->origin);

            switch (c->geometry->type) {
                case urdf::Geometry::BOX: {
                    auto g = std::dynamic_pointer_cast<urdf::Box>(c->geometry);
                    if (g) { lc.shape.type = ShapeType::BOX;
                             lc.shape.box = { g->dim.x, g->dim.y, g->dim.z }; }
                    break;
                }
                default:
                    continue; // skip meshes for now
            }

            out[i].push_back(std::move(lc));
        }
    }
    return out;
}


// ------------ Shapes ------------
enum class InShapeType : int { Box = 0, Sphere = 1, Cylinder = 2, Mesh = 3 };

struct InputShape {
  Eigen::Matrix<double,6,1> pose;   // [x,y,z, rx,ry,rz]
  Eigen::Vector3d           scale;  // [sx,sy,sz]
  InShapeType                 type;
};

Eigen::VectorXd radiansToDegrees6(const Eigen::VectorXd& x) {
    Eigen::VectorXd result = x;  // copy so original isn't modified
    for (int i = 0; i < 6; ++i) {
        result[i] = x[i] * 180.0 / PI;
    }
    return result;
}

// Convert first 6 elements from degrees → radians
Eigen::VectorXd degreesToRadians6(const Eigen::VectorXd& x) {
    Eigen::VectorXd result = x;
    for (int i = 0; i < 6; ++i) {
        result[i] = x[i] * PI / 180.0;
    }
    return result;
}


static std::vector<Eigen::VectorXd> run_planner(
    Eigen::VectorXd& q_start,
    Eigen::VectorXd& q_goal,
    const std::vector<InputShape>& scene,
    const std::vector<InputShape>& load,
    const Eigen::Matrix<double,6,1>& tool,
    const Eigen::Matrix<double,6,1>& base_in_world,
    const Eigen::Matrix<double,6,1>& frame_in_world,
    const std::array<Eigen::Vector3d,2>& aux_dir,
    double time_limit_sec)
{

    const int DOF = static_cast<int>(q_start.size());

    q_start = degreesToRadians6(q_start);
    q_goal = degreesToRadians6(q_goal);
    //starting planner section:

    // Your chain in order:
    std::vector<std::string> linkNames = {
        "j0_link", "j1_link", "j2_link", "j3_link", "j4_link", "j5_link", "j6_link"
    };

    // 1) Build FK
    const std::string urdfRel = "urdf/DornaTA.urdf";
    URDFFK urdf_fk(resource_path(urdfRel), linkNames);

    auto limits = std::vector<std::pair<double,double>>(DOF, std::make_pair(-PI, PI));

    // 2) Prepare link collision boxes (sizes & local offsets per link frame)
    // read per-link collisions from URDF
    auto links = extractLinkCollisionsFromURDF(urdf_fk.model(), linkNames);
    // fall back if a link has no collision data:
    for (auto& lcvec : links) if (lcvec.empty()) {
        std::cout<<"\n link is empty of collision shapes";
    }


    size_t lastLinkIndex = links.size() - 1;

    // 3) Scene & load (same structs as before)
    std::vector<ObjectInstance> out_scene; /* ... fill from your app ... */
    std::vector<ObjectInstance> out_load;  /* ... attached to last link ... */


    //scene generation
    for(int i=0; i<scene.size(); i++){
        ObjectInstance bin;
        bin.shape.type = ShapeType::BOX;
        auto o = scene[i];
        bin.shape.box  = {o.scale(0),o.scale(1),o.scale(2)};
        bin.pose.t     = Eigen::Vector3d(o.pose(0), o.pose(1), o.pose(2));
        bin.pose.rvec  = Eigen::Vector3d(o.pose(3), o.pose(4), o.pose(5));
        out_scene.push_back(bin);
    }
    //load generation
    for(int i=0; i<load.size(); i++){
        ObjectInstance bin;
        bin.shape.type = ShapeType::BOX;
        auto o = load[i];
        bin.shape.box  = {o.scale(0),o.scale(1),o.scale(2)};
        bin.pose.t     = Eigen::Vector3d(o.pose(0), o.pose(1), o.pose(2));
        bin.pose.rvec  = Eigen::Vector3d(o.pose(3), o.pose(4), o.pose(5));
        out_load.push_back(bin);
    } 


    //geometry stuff
    PoseAA base_pose, frame_pose;
    base_pose.set(base_in_world);
    frame_pose.set(frame_in_world);
    Eigen::Isometry3d base = base_pose.toIsometry();
    Eigen::Isometry3d frame = frame_pose.toIsometry();
    Eigen::Vector3d aux_dir_1 = base.rotation() * aux_dir[0];
    Eigen::Vector3d aux_dir_2 = base.rotation() * aux_dir[1];


    // 4) FK callback bridge for the validity checker
    fk_cb = [&](const Eigen::VectorXd& q, std::vector<Eigen::Isometry3d>& linkWorld){
        //aplying aux dirs
        Eigen::Isometry3d aux_base = base;
        if(q.size()>=7){
            aux_base.translate(aux_dir_1 * q[6]);
        }
        if(q.size()>=8){
            aux_base.translate(aux_dir_2 * q[7]);
        }

        Eigen::VectorXd q6;
        if (q.size() == 6) {
            q6 = q;
        } else {
            assert(q.size() >= 6 && "q must have at least 6 dofs");
            q6 = Eigen::VectorXd(q.head(6));  // construct a new VectorXd from the head
        }

        //calculating all values
        urdf_fk.compute(q6, linkWorld,  aux_base);
    };

    // 5) Planner setup (if your URDF exported N DOF, limits size == N)
    PlanOptions opts; opts.timeSeconds = 10.0; opts.range = 0.2;
    PlannerConfig cfg;
    cfg.kind  = PlannerKind::RRTConnect; // or PlannerKind::RRTstar / PRMstar
    cfg.range = 0.08;
    cfg.goalBias = 0.05;

    JointSpacePlanner planner(DOF, limits, links, lastLinkIndex, fk_cb, out_scene, out_load, frame, opts, cfg);

    auto result = planner.plan(q_start, q_goal);
    if (!result.solved) { std::vector<Eigen::VectorXd> empty_path; return  empty_path;}

    /*
    std::cout << "Waypoints: " << result.path.size() << "\n";
    for (auto& q : result.path) {
        for (int i=0;i<q.size();++i) std::cout << q[i] << (i+1<q.size()? " , " : "] , \n [");
    }
    */

    for(int i = 0 ;i<result.path.size();i++){
        result.path[i] = radiansToDegrees6( result.path[i] );
    }

    return result.path;
}

